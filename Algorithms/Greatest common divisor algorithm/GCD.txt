/*
НОД(2m, 2n) = 2 НОД(m, n),
НОД(2m, 2n+1) = НОД(m, 2n+1),
НОД(-m, n) = НОД(m, n)

НОД(0, n) = n; НОД(m, 0) = m;НОД(m, m) = m;
НОД(1, n) = 1; НОД(m, 1) = 1;
Если m, n чётные, то НОД(m, n) = 2*НОД(m/2, n/2);
Если m чётное, n нечётное, то НОД(m, n) = НОД(m/2, n);
Если n чётное, m нечётное, то НОД(m, n) = НОД(m, n/2);
Если m, n нечётные и n > m, то НОД(m, n) = НОД((n-m)/2, m);
Если m, n нечётные и n < m, то НОД(m, n) = НОД((m-n)/2, n);
*/

#include <iostream>

long long int GCD (long long int a, 
                   long long int b) 
{
	size_t shift;

	if (!a) // НОД(0, b) == b
		return b;
	if (!b) // НОД(a, 0) == a
		return a;

	// Вычисление shift == lg K, где K — наибольшая степень 2, на которую делятся без остатка a и b.
	for (shift = 0; !((a | b) & 1); ++shift) { // до тех пор, пока a и b — чётные
		a >>= 1;
		b >>= 1;
	}

	while (!(a & 1)) // до тех пор, пока a — чётное
		a >>= 1;

    // Начиная отсюда a всегда нечётно.
	do 
	{
		while (!(b & 1))  // // до тех пор, пока b — чётное
			b >>= 1;

		/* Теперь a и b нечётны, поэтому их разность чётна.
		   Вычисление a = min(a, b), b = (a - b) / 2. */
		if (a < b)
			b -= a;
		else 
			a -= (b = a - b);
			
		b >>= 1;
		
	} while (b);

	return a << shift;
}

int main()
{
    std::cout << GCD(10, 20);

    return 0;
}